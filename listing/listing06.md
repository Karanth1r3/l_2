Что выведет программа? Объяснить вывод программы. Рассказать про внутреннее устройство слайсов и что происходит при передачe их в качестве аргументов функции.

package main

import (
  "fmt"
)

func main() {
  var s = []string{"1", "2", "3"}
  modifySlice(s)
  fmt.Println(s)
}

func modifySlice(i []string) {
  i[0] = "3"
  i = append(i, "4")
  i[1] = "5"
  i = append(i, "6")
}
Ответ:

...
Слайсы передаются в функции по значению, как и все другие типы в Go, но копия слайса в переданной функции будет содержать ссылку на тот же массив, что и оригинальный. Срез - структура, состоящая из 3 полей - unsafe.Pointer - ссылка на массив, len - длина среза, cap - ёмкость среза (считается от первого элемента среза до последнего элемента массива, более наглядно это можно увидеть, если взять слайс [x:y] над массивом). Когда переполняется cap (например, при присвоении результата через append), слайс уже ссылается на другой массив, поэтому при таком раскладе дальнейшие изменения над слайсом-параметром функции будут происходить с другим массивом, а оригинальный слайс останется неизменен. В данном примере изначально создается слайс длиной и ёмкостью 3. Затем он передается в функцию, где меняется его нулевой элемент - т.к. слайс-параметр и оригинальный слайс пока ссылаются на один массив, изменения затронут и параметр, и оригинал. Однако далее вызывается функция append. Во-первых, параметру присвоится новый слайс (копия, возвращаемая функцией append). Во-вторых, т.к. происходит переполнение, слайс-параметр после выполнения append будет ссылаться на другой массив, нежели оригинальный. Поэтому дальнейшие операции (как и сам append) не повлияют на оригинальный срез.
=> Вывод: [3, 2, 3]